// Copyright 2025 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go-corset DO NOT EDIT

package mersenne31

import (
	"math/big"
	"math/rand/v2"
	"testing"

	"github.com/consensys/go-corset/pkg/util/assert"
)

func TestMul(t *testing.T) {
	var i, j, m big.Int

	m.SetUint64(Modulus)

	for range 10000 {
		a := rand.Uint32N(Modulus)
		b := rand.Uint32N(Modulus)

		i.SetUint64(uint64(a)).
			Mul(&i, j.SetUint64(uint64(b))).
			Lsh(&i, 32).
			Mod(&i, &m)

		x := New(a)
		y := New(b)

		x = x.Mul(y)

		assert.Equal(t, i.Uint64(), x[0])
	}
}

func TestInverse(t *testing.T) {
	var i, m big.Int

	m.SetUint64(Modulus)

	for range 1000000 {
		a := rand.Uint32N(Modulus-1) + 1 // avoid 0.

		i.SetUint64(uint64(a)).
			ModInverse(&i, &m).
			Lsh(&i, 32). // Montgomery form
			Mod(&i, &m)

		x := New(a)
		x = x.Inverse()

		assert.Equal(t, i.Uint64(), x[0], "inverse of %d", a)
	}
}

func TestHalve(t *testing.T) {
	var i, j, m big.Int

	m.SetUint64(Modulus)

	for range 1000000 {
		a := rand.Uint32N(Modulus)
		x := New(a)
		x = x.Half()

		i.SetUint64(uint64(x[0])).Add(&i, &i).Mod(&i, &m) // (a/2) as computed, multiplied by 2
		j.SetUint64(uint64(a)).Lsh(&j, 32).Mod(&j, &m)    // Montgomery representation of a

		assert.Equal(t, j.Uint64(), i.Uint64(), "halving of %d", a)
	}
}

func TestSub(t *testing.T) {
	var i, j, m big.Int

	m.SetUint64(Modulus)

	for range 100000 {
		a := rand.Uint32N(Modulus)
		b := rand.Uint32N(Modulus)

		i.SetUint64(uint64(a)).
			Sub(&i, j.SetUint64(uint64(b))).
			Lsh(&i, 32).
			Mod(&i, &m)

		x := New(a)
		y := New(b)

		x = x.Sub(y)

		assert.Equal(t, i.Uint64(), x[0])
	}
}

func TestMontgomery(t *testing.T) {
	m := big.NewInt(Modulus)
	i := big.NewInt(1 << 32)
	i.Mod(i, m)

	x := New(1)
	assert.Equal(t, i.Uint64(), x[0])

	x = montgomeryReduce(uint64(x[0]))
	assert.Equal(t, 1, x[0])
}

func TestByteConversion(t *testing.T) {
	var i big.Int
	for range 1000000 {
		a := rand.Uint32N(Modulus)
		expectedB := i.SetUint64(uint64(a)).Bytes()
		expectedB = append(make([]byte, nbBytes-len(expectedB)), expectedB...) // pad to nbBytes

		// bytes to element
		x := Element{}.AddBytes(expectedB)
		assert.Equal(t, New(a), x)

		// element to bytes
		assert.Equal(t, expectedB, x.Bytes())
	}
}

func TestZeroOne(t *testing.T) {
	zero := New(0)
	one := New(1)

	assert.True(t, zero.IsZero())
	assert.False(t, one.IsZero())
	assert.False(t, zero.IsOne())
	assert.True(t, one.IsOne())

	assert.Equal(t, zero, zero.Add(zero))
	assert.Equal(t, one, zero.Add(one))
	assert.Equal(t, one, one.Mul(one))
	assert.Equal(t, zero, one.Mul(zero))
}
