// Copyright 2025 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go-corset DO NOT EDIT

package mersenne31

import (
	"cmp"
	"math/bits"
	"strconv"
)

// Element of a prime order field, represented in Montgomery form to speed up multiplications.
type Element [1]uint32 // defined as an array to prevent mistaken use of arithmetic operators, or naive assignments.

const (
	r                 = 1 << 32 // register size
	modulus           = 2147483647
	rModM             = 2
	rSqModM           = 4          // r² (mod m)
	negModulusInvModR = 2147483649 // -modulus⁻¹ (mod r), used for Montgomery reduction
	nbBytes           = 4
)

// Add x + y
func (x Element) Add(y Element) Element {
	res := x[0] + y[0]

	if reduced, borrow := bits.Sub32(res, modulus, 0); borrow == 0 {
		res = reduced
	}

	return Element{res}
}

// Sub x - y
func (x Element) Sub(y Element) Element {
	res, borrow := bits.Sub32(x[0], y[0], 0)
	if borrow != 0 {
		res += modulus
	}

	return Element{res}
}

// montgomeryReduce x -> x.R⁻¹ (mod m)
func montgomeryReduce(x uint64) Element {
	// textbook Montgomery reduction
	m := (x * uint64(negModulusInvModR)) % r // m = x * (-modulus⁻¹) (mod r)

	res := uint32((x + m*modulus) / r)

	diff, borrow := bits.Sub32(res, modulus, 0)
	if borrow == 0 {
		res = diff
	}

	return Element{res}
}

// AddUint32 x + y
func (x Element) AddUint32(y uint32) Element {
	return x.Add(New(y))
}

// ToUint32 returns the numerical (non-Montgomery)
// value of x.
func (x Element) ToUint32() uint32 {
	return montgomeryReduce(uint64(x[0]))[0]
}

// Mul x * y
func (x Element) Mul(y Element) Element {
	return montgomeryReduce(uint64(x[0]) * uint64(y[0]))
}

// New returns an element of the field f corresponding to the natural number x.
func New(x uint32) Element {
	return Element{x}.Mul(Element{rSqModM})
}

// Cmp compares the numerical values of x and y.
func (x Element) Cmp(y Element) int {
	return cmp.Compare(x.ToUint32(), y.ToUint32())
}

// Double x -> 2x
func (x Element) Double() Element {
	return x.Add(x)
}

// Half x -> x/2 (mod m).
func (x Element) Half() Element {
	if x[0]%2 == 0 {
		return Element{x[0] / 2}
	} else {
		return Element{(x[0] + modulus) / 2} // the modulus is less than 2³¹ so this is safe.
	}
}

// Inverse x -> x⁻¹ (mod m) or 0 if x = 0
func (x Element) Inverse() Element {
	// Algorithm 16 in "Efficient Software-Implementation of Finite Fields with Applications to Cryptography"
	if x[0] == 0 {
		return Element{0}
	}

	u := x[0]
	v := uint32(modulus)

	var c Element
	// Since x actually contains x.R, we have to multiply the result by R² to get x⁻¹R⁻¹R² = x⁻¹R.
	b := Element{rSqModM}

	for (u != 1) && (v != 1) {
		for u%2 == 0 {
			u /= 2
			b = b.Half()
		}

		for v%2 == 0 {
			v /= 2
			c = c.Half()
		}

		if diff, borrow := bits.Sub32(u, v, 0); borrow == 0 {
			u = diff
			b = b.Sub(c)
		} else {
			v -= u
			c = c.Sub(b)
		}
	}

	if u == 1 {
		return b
	} else {
		return c
	}
}

// String returns the value of x based 10.
func (x Element) String() string {
	return strconv.FormatUint(uint64(x.ToUint32()), 10)
}

// Text returns the value of x in the given base.
func (x Element) Text(base int) string {
	return strconv.FormatUint(uint64(x.ToUint32()), base)
}

// Bytes returns the big-endian encoded value of the Element, possibly with leading zeros.
func (x Element) Bytes() []byte {
	res := make([]byte, nbBytes)
	v := x.ToUint32()
	for i := range nbBytes {
		res[i] = byte(v >> ((nbBytes - 1 - i) * 8))
	}
	return res
}

// AddBytes adds the Element to the given big-endian value. It expects exactly 4  input bytes.
func (x Element) AddBytes(b []byte) Element {
	if len(b) != nbBytes {
		panic("AddBytes expects 4 bytes")
	}
	var v uint32
	for i := range nbBytes {
		v |= uint32(b[i]) << ((nbBytes - 1 - i) * 8)
	}
	return x.Add(New(v))
}

func (x Element) IsZero() bool {
	return x[0] == 0
}

func (x Element) IsOne() bool {
	return x[0] == rModM
}
