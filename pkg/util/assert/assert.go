package assert

import (
	"fmt"
	"math"
	"reflect"
	"runtime"
	"strings"
	"testing"
	"unicode"
	"unicode/utf8"
)

// Equal errors if actual is not equal to expected.
func Equal(t *testing.T, expected, actual any, msg ...any) {
	if reflect.DeepEqual(expected, actual) || intEqual(expected, actual) {
		return
	}

	t.Errorf("expected: %v, actual: %v\nError Trace: %s", expected, actual, strings.Join(callerInfo(), "\n\t\t\t"))

	if len(msg) != 0 {
		t.Errorf(msg[0].(string), msg[1:]...)
	}

	t.Fail()
}

// intEqual returns whether expected and actual are both integers and whether they are equal
// if that is the case.
func intEqual(expected, actual any) bool {
	a, aInt64 := asInt64(expected)
	b, bInt64 := asInt64(actual)

	if aInt64 != bInt64 {
		return false
	}

	if aInt64 {
		return a == b
	}

	x, aUint64 := expected.(uint64)
	y, bUint64 := actual.(uint64)

	if !aUint64 || !bUint64 {
		return false
	}

	return x == y
}

// asInt64 tries to convert x to an int64 and specifies if the conversion was successful or
// if x only can be expressed as a uint64
func asInt64(x any) (int64, bool) {
	if y, ok := x.(uint64); ok && y > math.MaxInt64 {
		return 0, false
	}

	switch x := x.(type) {
	case int:
		return int64(x), true
	case int8:
		return int64(x), true
	case int16:
		return int64(x), true
	case int32:
		return int64(x), true
	case int64:
		return x, true
	case uint:
		return int64(x), true
	case uint8:
		return int64(x), true
	case uint16:
		return int64(x), true
	case uint32:
		return int64(x), true
	case uint64:
		return int64(x), true
	}

	return 0, false
}

// callerInfo returns an array of strings containing the file and line number
// of each stack frame leading from the current test to the assert call that
// failed.
// Stolen from https://github.com/stretchr/testify
func callerInfo() []string {
	var pc uintptr

	var file string

	var line int

	var name string

	const stackFrameBufferSize = 10
	pcs := make([]uintptr, stackFrameBufferSize)

	callers := []string{}
	offset := 1

	for {
		n := runtime.Callers(offset, pcs)

		if n == 0 {
			break
		}

		frames := runtime.CallersFrames(pcs[:n])

		for {
			frame, more := frames.Next()
			pc = frame.PC
			file = frame.File
			line = frame.Line

			// This is a huge edge case, but it will panic if this is the case, see #180
			if file == "<autogenerated>" {
				break
			}

			f := runtime.FuncForPC(pc)
			if f == nil {
				break
			}

			name = f.Name()

			// testing.tRunner is the standard library function that calls
			// tests. Subtests are called directly by tRunner, without going through
			// the Test/Benchmark/Example function that contains the t.Run calls, so
			// with subtests we should break when we hit tRunner, without adding it
			// to the list of callers.
			if name == "testing.tRunner" {
				break
			}

			parts := strings.Split(file, "/")
			if len(parts) > 1 {
				filename := parts[len(parts)-1]
				dir := parts[len(parts)-2]

				if (dir != "assert" && dir != "mock" && dir != "require") || filename == "mock_test.go" {
					callers = append(callers, fmt.Sprintf("%s:%d", file, line))
				}
			}

			// Drop the package
			dotPos := strings.LastIndexByte(name, '.')

			name = name[dotPos+1:]
			if isTest(name, "Test") ||
				isTest(name, "Benchmark") ||
				isTest(name, "Example") {
				break
			}

			if !more {
				break
			}
		}

		// Next batch
		offset += cap(pcs)
	}

	return callers
}

// Stolen from the `go test` tool.
// isTest tells whether name looks like a test (or benchmark, according to prefix).
// It is a Test (say) if there is a character after Test that is not a lower-case letter.
// We don't want TesticularCancer.
func isTest(name, prefix string) bool {
	if !strings.HasPrefix(name, prefix) {
		return false
	}

	if len(name) == len(prefix) { // "Test" is ok
		return true
	}

	r, _ := utf8.DecodeRuneInString(name[len(prefix):])

	return !unicode.IsLower(r)
}
