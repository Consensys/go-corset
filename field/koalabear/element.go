// Copyright 2025 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go-corset DO NOT EDIT

package koalabear

import (
	"cmp"
	"math/bits"
)

// Element of a prime order field, represented in Montgomery form to speed up multiplications.
type Element [1]uint32 // defined as an array to prevent mistaken use of arithmetic operators, or naive assignments.

const (
	r                 = 1 << 32 // register size
	modulus           = 2130706433
	rSq               = 402124772  // r² (mod m)
	negModulusInvModR = 2164260863 // -modulus⁻¹ (mod r), used for Montgomery reduction
)

// Add x + y
func (x Element) Add(y Element) Element {
	res := x[0] + y[0]

	if reduced, borrow := bits.Sub32(res, modulus, 0); borrow == 0 {
		res = reduced
	}

	return Element{res}
}

// Sub x - y
func (x Element) Sub(y Element) Element {
	res, borrow := bits.Sub32(x[0], y[0], 0)
	if borrow != 0 {
		res += modulus
	}

	return Element{res}
}

// montgomeryReduce x -> x.R⁻¹ (mod m)
func montgomeryReduce(x uint64) Element {
	// textbook Montgomery reduction
	m := (x * uint64(negModulusInvModR)) % r // m = x * (-modulus⁻¹) (mod r)

	res := Element{uint32((x + m*modulus) / r)}

	if res[0] >= modulus {
		res[0] -= modulus
	}

	return res
}

// ToUint32 returns the numerical (non-Montgomery)
// value of x.
func (x Element) ToUint32() uint32 {
	return montgomeryReduce(uint64(x[0]))[0]
}

// Mul x * y
func (x Element) Mul(y Element) Element {
	return montgomeryReduce(uint64(x[0]) * uint64(y[0]))
}

// NewElement returns an element of the field f corresponding to the natural number x.
func NewElement(x uint32) Element {
	return Element{uint32(uint64(x) << 32 % modulus)}
}

// Cmp compares the numerical values of x and y.
func (x Element) Cmp(y Element) int {
	return cmp.Compare(x.ToUint32(), y.ToUint32())
}

// Double x -> 2x
func (x Element) Double() Element {
	return x.Add(x)
}

// Half x -> x/2 (mod m).
func (x Element) Half() Element {
	if x[0]%2 == 0 {
		return Element{x[0] / 2}
	} else {
		return Element{(x[0] + modulus) / 2} // the modulus is less than 2³¹ so this is safe.
	}
}

// Inverse x -> x⁻¹ (mod m) or 0 if x = 0
func (x Element) Inverse() Element {
	// Algorithm 16 in "Efficient Software-Implementation of Finite Fields with Applications to Cryptography"
	if x[0] == 0 {
		return Element{0}
	}

	u := x[0]
	v := uint32(modulus)

	var c Element
	// Since x actually contains x.R, we have to multiply the result by R² to get x⁻¹R⁻¹R² = x⁻¹R.
	b := Element{rSq}

	for (u != 1) && (v != 1) {
		for u%2 == 0 {
			u /= 2
			b = b.Half()
		}

		for v%2 == 0 {
			v /= 2
			c = c.Half()
		}

		if diff, borrow := bits.Sub32(u, v, 0); borrow == 0 {
			u = diff
			b = b.Sub(c)
		} else {
			v -= u
			c = c.Sub(b)
		}
	}

	if u == 1 {
		return b
	} else {
		return c
	}
}
