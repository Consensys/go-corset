;; GF251 curve
;; Add on u256
;; Mul on u8, to be able to test all cases

fn add(x u256, y u256) -> (RESULT u256) {

   var c0, c1  u1
   var res u256
   var red u256

   c0, res = x + y
   c1, red = res - 251
   ;; if c1 is 0, it means the diff is positive and res is >= 251
   ;; if c1 is 1, diff is negative, res < 251
   if c1==0 goto exit0
   RESULT = res
   return
exit0:
   RESULT = red
   return

}

;; u8 version of mul and reduction to be able to test all cases

fn reduction_u8(z u16) -> (RESULT u8) {
   ;; constants recap
   ;; R = 256 = 2^8
   ;; n = 251
   ;; ninv mod R = 205

   var n u8
   var ninv_mod_R u8

   var quot u8
   var tmp_quot u16
   var quot_times_n u16
   var discard_bit_shift u8
   var res u8
   var red u8
   var c0, c1 u1

   ninv_mod_R = 205
   n = 251

   ;; z is a u16
   ;; compute z mod R by masking
   ;; find quot
   ;; compute mod R by masking
   tmp_quot, quot = z * ninv_mod_R

   ;; compute the dividend
   ;; and / R with a bit shift
   quot_times_n = quot * n
   c1, res, discard_bit_shift = z + quot_times_n

   ;; precompute red before checking the carries
   c0, red = res - n

   ;; if c1 == 1, it means res was >= 256 so we return red
   if c1==1 goto exit_1
   ;; if c0 == 0, (res - n) is positive and res >= 251 so we return red as well
   if c0==0 goto exit_1
   RESULT = res
   return
exit_1:
   RESULT = red
   return
}

fn mul_u8(x u8, y u8) -> (RESULT u8) {
    var new_x u16
    var new_y u16
    var tmp_x u8
    var tmp_y u8
    ;; RÂ² mod n is 25
    new_x = x * 25
    new_y = y * 25
    tmp_x = reduction_u8(new_x)
    tmp_y = reduction_u8(new_y)
    var z u16
    var zz u8
    var zzz u16
    z = tmp_x * tmp_y
    zz = reduction_u8(z)
    zzz = zz
    RESULT = reduction_u8(zzz)
    return
}
