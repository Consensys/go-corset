;; GF251 curve
;; Add, Mul on u8, to be able to test all cases

fn add(x u8, y u8) -> (RESULT u8) {

   var c0, c1  u1
   var res u8
   var red u8

   c0, res = x + y
   c1, red = res - 251
   ;; if c1 is 0, it means the diff is positive and res is >= 251
   ;; if c1 is 1, diff is negative, res < 251
   if c1==0 goto exit0
   RESULT = res
   return
exit0:
   RESULT = red
   return

}

fn reduction(z u16) -> (RESULT u8) {
   ;; constants recap
   ;; R = 256 = 2^8
   ;; n = 251
   ;; ninv mod R = 205

   var quot u8
   var tmp_quot u16
   var quot_times_n u16
   var discard_bit_shift u8
   var res u8
   var red u8
   var c0, c1 u1

   ;; z is a u16
   ;; compute z mod R by masking
   ;; find quot
   ;; compute mod R by masking
   tmp_quot, quot = z * 205

   ;; compute the dividend
   ;; and / R with a bit shift
   quot_times_n = quot * 251
   c1, res, discard_bit_shift = z + quot_times_n

   ;; precompute red before checking the carries
   c0, red = res - 251

   ;; if c1 == 1, it means res was >= 256 so we return red
   if c1==1 goto exit_1
   ;; if c0 == 0, (res - n) is positive and res >= 251 so we return red as well
   if c0==0 goto exit_1
   RESULT = res
   return
exit_1:
   RESULT = red
   return
}

fn mul(x u8, y u8) -> (RESULT u8) {
    var new_x u8
    var new_y u8
    var tmp_x u16
    var tmp_y u16
    ;; RÂ² mod n is 25
    tmp_x = x * 25
    tmp_y = y * 25
    new_x = reduction(tmp_x)
    new_y = reduction(tmp_y)
    var tmp_z u16
    var z_u8 u8
    var z_u16 u16
    tmp_z = new_x * new_y
    z_u8 = reduction(tmp_z)
    z_u16 = z_u8
    RESULT = reduction(z_u16)
    return
}
