;; GF251 curve
;; Mul on u8, to be able to test all cases

;; u8 version of mul and reduction to be able to test all cases

fn reduction_u8(z u16) -> (RESULT u8) {
   ;; constants recap
   ;; R = 256 = 2^8
   ;; n = 251
   ;; ninv mod R = 205

   var n u8
   var ninv_mod_R u8

   var z_mod_R u8
   var tmp_z_mod_R u8

   var m u8
   var tmp_m u8
   var m_times_n u16
   var dividend u16
   var discard_bit_shift u8
   var res u8
   var red u8
   var c0, c1, c2 u1

   ninv_mod_R = 205
   n = 251

   ;; z is a u16
   ;; compute z mod R by masking
   tmp_z_mod_R, z_mod_R = z

   ;; find m
   ;; compute mod R by masking
   tmp_m, m = z_mod_R * ninv_mod_R

   ;; compute the dividend
   m_times_n = m * n
   c1, dividend = z + m_times_n

   ;; dividend / R
   res, discard_bit_shift = dividend

   ;; old version that contained a bug
   ;; leaving it here to show David the compiler issue

      ;; limb 1 of result
      ;; z / R
      ;; z_div_R, discard_bit_shift = z

      ;; limb 2 of result
      ;; ( m * n ) / R
      ;; m_times_n_div_R, discard_bit_shift = m * n

      ;; compute the result of the reduction limb1 + limb2
      ;; c2, res = z_div_R + m_times_n_div_R

   c0, red = res - n
   if c0==0 goto exit_1
   goto exit_0
exit_0:
   RESULT = res
   return
exit_1:
   RESULT = red
   return
}

;; TODO: uncomment once fn call in fn is fixed
;;fn mul_u8(x u8, y u8) -> (RESULT u8) {
;;    var z u16
;;    z = x * y
;;    RESULT = reduction_u8(z)
;;    return
;;}
