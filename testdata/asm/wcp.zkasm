;; GEQ                              0x0E
;; LEQ                              0x0F
;; LT                               0x10
;; GT                               0x11
;; SLT                              0x12
;; SGT                              0x13
;; EQ                               0x14
;; ISZERO                           0x15
fn wcp(INST u8, ARGUMENT_1 u256, ARGUMENT_2 u256) -> (RESULT u1) {
   var delta u256
   var arg1bits, arg2bits u255
   var borrow,arg1sign,arg2sign u1
   ;;
   if INST==14 goto geq
   if INST==15 goto leq
   if INST==16 goto lt
   if INST==17 goto gt
   if INST==18 goto slt
   if INST==19 goto sgt
   if INST==20 goto eq
   ;; BROKEN: invalid case should fail
   goto isz
leq:
   borrow,delta = ARGUMENT_2 - ARGUMENT_1
   if borrow==0 goto exit_1
   goto exit_0
geq:
   borrow,delta = ARGUMENT_1 - ARGUMENT_2
   if borrow==0 goto exit_1
   goto exit_0
lt:
   borrow,delta = ARGUMENT_1 - ARGUMENT_2
   if borrow!=0 goto exit_1
   goto exit_0
gt:
   borrow,delta = ARGUMENT_2 - ARGUMENT_1
   if borrow!=0 goto exit_1
   goto exit_0
slt:
   arg1sign,arg1bits = ARGUMENT_1
   arg2sign,arg2bits = ARGUMENT_2
   ;; pos/pos or neg/neg?
   if arg1sign==arg2sign goto lt
   ;; pos/neg?
   if arg2sign==1 goto exit_0
   ;; neg/pos
   goto exit_1
sgt:
   arg1sign,arg1bits = ARGUMENT_1
   arg2sign,arg2bits = ARGUMENT_2
   ;; pos/pos or neg/neg?
   if arg1sign==arg2sign goto gt
   ;; pos/neg?
   if arg2sign==1 goto exit_1
   ;; neg/pos
   goto exit_0
eq:
   if ARGUMENT_1==ARGUMENT_2 goto exit_1
   goto exit_0
isz:
   if ARGUMENT_1==0 goto exit_1
exit_0:
   RESULT = 0
   return
exit_1:
   RESULT = 1
   return
}
