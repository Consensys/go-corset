;; https://eips.ethereum.org/EIPS/eip-7702

;; TODO: look at rlpauth spec, prepare arguments and execute a lookup to the hub
;;       macro: data coming from rlptxn module
;;       xtern: data extracted from the hub
;; TODO: the most important part is the interface for communicating with the HUB

;; TODO: do we have an shared notation for constants, function arguments...?
;; const SECP256K1N = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
const SECP256K1N_DIVIDED_BY_TWO = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe17
const MAGIC = 0x05

;; TODO: add sender (TXN_FROM_ADDRESS) as an argument of the function, and compare it later with authority to compute SENDER_IS_AUTHORITY
;;       it can be obtained either from RLPTXN or from the HUB, which internally gets it from TXNDATA (TBD). Lookup to the HUB is probably the best solution
fn rlpauth(chain_id u256, nonce u256, address u160, y_parity u8, r u256, s u256) -> (authority u160, error u1)
{
    ;; The following checks are enforced by the types above:
    ;; assert auth.chain_id < 2**256
    ;; assert auth.nonce < 2**64
    ;; assert len(auth.address) == 20
    ;; assert auth.y_parity < 2**8
    ;; assert auth.r < 2**256
    ;; assert auth.s < 2**256
    step_1:
        ;; Verify that chain_id is 0 or the ID of the current chain
        if chain_id == 0 goto step_2
        if chain_id == 1 goto step_2 ;; TODO: current chain_id should be obtained via a lookup to blockdata
        fail
    step_2:
        var b u1
        var tmp2 u256
        b, tmp2 = nonce - 2^64
        if b == 0 goto failure ;; nonce < 2^64
    step_3:
        ;; Check that s <= SECP256K1N_DIVIDED_BY_TWO
        var tmp3 u256
        b, tmp3 = s - SECP256K1N_DIVIDED_BY_TWO
        if b == 1 goto failure
        ;;
        var rlp_res u256
        rlp_res = compute_rlp(chain_id, address, nonce)
        ;;
        var keccak_input u264
        keccak_input = (MAGIC * 2^256) + rlp_res
        ;;
        var msg u256
        msg = keccak(keccak_input)
        authority = ecrecover(msg, y_parity, r, s)
        ;; step_4: happens in the HUB
        ;; Add authority to accessed_addresses, as defined in EIP-2929.
    step_5:
        ;; TODO: I get the information for this step via a lookup to the HUB, it is a single bit representing
        ;; if we are in one of the two cases below
        ;; code_of_authority_is_empty_or_delegated
        ;; if authority is emtpy goto step_6
        ;; if authority is already delegated goto step_6
        ;; fail
    step_6:
        ;; TODO: a lookup is obtained by a combination of legacy lisp and zkasm. Ask Francois
        ;; TODO: authority.nonce is coming from the hub
        ;; NOTE: the sender.nonce will be incremented after the authority list in Linea; if sender == authority (SENDER_IS_AUTHORITY) one must verify authority.nonce + 1 == nonce (TBC)
        ;; if authority.nonce == nonce goto step_7
        ;; fail
    ;; step_7: happens in the HUB
        ;; Add PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST gas to the global refund counter if authority is not empty.
    step_8:
        ;; TODO: compute the hash of 0xef0100 || address (send this to the prover, along with the expected code_hash, so as the prover proves it is correct)
        ;; if address == 0x0000000000000000000000000000000000000000 goto "authority.code_hash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"
        ;; authority.code = (0xef0100 * 2^160) + address
        ;; TODO: look at Into HUB lookup and compute all the required values
    ;; step_9: happens in the HUB
        ;; authority.nonce = authority.nonce + 1
    exit:
        ;; dummy values
        authority = 0
        error = 0
        return
    failure:
        fail
}

;; temporary dummy functions
;; TODO: determine the exact size of RLP
fn compute_rlp(chain_id u256, address u160, nonce u256) -> (rlp_res u256) {
    rlp_res = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
    return
}

;; TODO: discuss with David and Azam how to communicate with the prover for computing these 2 functions below
fn keccak(keccak_input u264) -> (keccak_output u256) {
    keccak_output = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
    return
}

fn ecrecover(msg u256, y_parity u8, r u256, s u256) -> (ecrecover_result u160) {
    ecrecover_result = 0xfffffffffffffffffffffffffffffffefffffc2f
    return
}
