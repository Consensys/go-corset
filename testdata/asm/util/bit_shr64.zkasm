;; Shift a u64 word a given number of bits to the right.  The
;; implementation performs a decomposition on the shift, starting with
;; the most significant bit.
fn bit_shr64(word u64, n u6) -> (res u64) {
  var b u1
  var m u5
  var msw u64
  var lsw u32
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shr64_u5((word,m)
  return
apply:
  msw, lsw = word
  res = bit_shr64_u5(msw,m)
  return
}

fn bit_shr64_u5(word u64, n u5) -> (res u64) {
  var b u1
  var m u4
  var msw u64
  var lsw u16
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shr64_u4(word,m)
  return
apply:
  msw, lsw = word
  res = bit_shr64_u4(msw,m)
  return
}

fn bit_shr64_u4(word u64, n u4) -> (res u64) {
  var b u1
  var m u3
  var msw u64
  var lsw u8
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shr64_u3(word,m)
  return
apply:
  msw, lsw = word
  res = bit_shr64_u3(msw,m)
  return
}

fn bit_shr64_u3(word u64, n u3) -> (res u64) {
  var b u1
  var m u2
  var msw u64
  var lsw u4
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shr64_u2(word,m)
  return
apply:
  msw, lsw = word
  res = bit_shr64_u2(msw,m)
  return
}

fn bit_shr64_u2(word u64, n u2) -> (res u64) {
  var b u1
  var m u1
  var msw u64
  var lsw u2
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shr64_u1(word,m)
  return
apply:
  ;; >>> START: workaround #1176
  var hi u30
  var lo u30
  var mid u2
  hi, mid, lo, lsw = word
  msw = (hi * 2^32) + (mid * 2^30) + lo
  ;; <<< END
  res = bit_shr64_u1(msw,m)
  return
}

fn bit_shr64_u1(word u64, n u1) -> (res u64) {
  var lsw u1
  ;;
  if n!=0 goto apply
  res = word
  return
apply:
  ;; >>> START: workaround #1176
  var hi u31
  var lo u31
  var mid u1
  hi, mid, lo, lsw = word
  res = (hi * 2^32) + (mid * 2^31) + lo
  ;; <<< END
  return
}