;; Shift a u64 word a given number of bits to the left.  The
;; implementation performs a decomposition on the shift, starting with
;; the most significant bit.
fn bit_shl64(word u64, n u6) -> (res u64) {
  var lsw u32
  var msw u32
  var b u1
  var m u5
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shl64_u5(word,m)
  return
apply:
  msw, lsw = word
  res = bit_shl64_u5(lsw * 2^32, m)
  return
}

fn bit_shl64_u5(word u64, n u5) -> (res u64) {
  var lsw u48
  var msw u16
  var b u1
  var m u4
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shl64_u4(word,m)
  return
apply:
  msw, lsw = word
  res = bit_shl64_u4(lsw * 2^16, m)
  return
}

fn bit_shl64_u4(word u64, n u4) -> (res u64) {
  var lsw u56
  var msw u8
  var b u1
  var m u3
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shl64_u3(word,m)
  return
apply:
  msw, lsw = word
  res = bit_shl64_u3(lsw * 2^8, m)
  return
}

fn bit_shl64_u3(word u64, n u3) -> (res u64) {
  var lsw u60
  var msw u4
  var b u1
  var m u2
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shl64_u2(word,m)
  return
apply:
  msw, lsw = word
  res = bit_shl64_u2(lsw * 2^4, m)
  return
}

fn bit_shl64_u2(word u64, n u2) -> (res u64) {
  var lsw u62
  var msw u2
  var b u1
  var m u1
  ;; decompose shift
  b,m = n
  ;;
  if b!=0 goto apply
  res = bit_shl64_u1(word,m)
  return
apply:
  msw, lsw = word
  res = bit_shl64_u1(lsw * 2^2, m)
  return
}

fn bit_shl64_u1(word u64, n u1) -> (res u64) {
  var lsw u63
  var msw u1
  ;;
  if n!=0 goto apply
  res = word
  return
apply:
  msw, lsw = word
  res = lsw * 2
  return
}