;; GF251 curve
;; Add, Mul on u8, to be able to test all cases

const R = 2^8
;; Prime modulus
const N = 251
;; Represents -1/N mod R.
const NEG_INV_N = 205

fn add(x u8, y u8) -> (RESULT u8) {
   var c0, c1  u1
   var res u8
   var red u8

   c0, res = x + y
   c1, red = res - N
   ;; if c1 == 1, it means res was >= 256 so we return red
   if c0==1 goto exit_0
   ;; if c1 is 0, it means the diff is positive and res is >= N, so we return red
   ;; if c1 is 1, diff is negative, res < N
   if c1==0 goto exit_0
   RESULT = res
   return
exit_0:
   RESULT = red
   return
}

fn reduction(z u16) -> (RESULT u8) {
   var quot u8
   var tmp_quot u16
   var quot_times_n u16
   var discard_bit_shift u8
   var res u8
   var red u8
   var c0, c1 u1

   ;; z is a u16
   ;; compute z mod R by masking
   ;; find quot
   ;; compute mod R by masking
   tmp_quot, quot = z * NEG_INV_N

   ;; compute the dividend
   ;; and / R with a bit shift
   quot_times_n = quot * N
   c1, res, discard_bit_shift = z + quot_times_n

   ;; precompute red before checking the carries
   c0, red = res - N

   ;; if c1 == 1, it means res was >= 256 so we return red
   if c1==1 goto exit_0
   ;; if c0 == 0, (res - n) is positive and res >= N so we return red as well
   if c0==0 goto exit_0
   RESULT = res
   return
exit_0:
   RESULT = red
   return
}

fn mul(x u8, y u8) -> (RESULT u8) {
    var tmp_x u16
    var tmp_y u16
    var new_x u8
    var new_y u8
    ;; R² mod n is 25
    tmp_x = x * 25
    tmp_y = y * 25
    ;; reduction of T is equivalent to (T * R⁻1) mod n
    ;; reduction gives new_x = (x * R²) R⁻1 mod n = (x * R) mod n
    new_x = reduction(tmp_x)
    new_y = reduction(tmp_y)
    var tmp_z u16
    var z_u8 u8
    var z_u16 u16
    tmp_z = new_x * new_y
    ;; reduction gives (x * y * R) mod n
    z_u8 = reduction(tmp_z)
    z_u16 = z_u8
    ;; last reduction gives (x * y) mod n
    RESULT = reduction(z_u16)
    return
}
