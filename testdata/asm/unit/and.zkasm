;; AND module - to be used in BIN

fn and(ARG_1 u256, ARG_2 u256) -> (RES u256) {
  var arg1_lo, arg1_hi, arg2_lo, arg2_hi, res_hi, res_lo u128
  arg1_hi, arg1_lo = ARG_1
  arg2_hi, arg2_lo = ARG_2
  res_hi = and_u128(arg1_hi, arg2_hi)
  res_lo = and_u128(arg1_lo, arg2_lo)
  RES = ( res_hi * 2^128 ) + res_lo
  return
}

fn and_u128(ARG_1 u128, ARG_2 u128) -> (RES u128) {
  var arg1_lo, arg1_hi, arg2_lo, arg2_hi, res_hi, res_lo u64
  arg1_hi, arg1_lo = ARG_1
  arg2_hi, arg2_lo = ARG_2
  res_hi = and_u64(arg1_hi, arg2_hi)
  res_lo = and_u64(arg1_lo, arg2_lo)
  RES = ( res_hi * 2^64 ) + res_lo
  return
}

fn and_u64(ARG_1 u64, ARG_2 u64) -> (RES u64) {
  var arg1_lo, arg1_hi, arg2_lo, arg2_hi, res_hi, res_lo u32
  arg1_hi, arg1_lo = ARG_1
  arg2_hi, arg2_lo = ARG_2
  res_hi = and_u32(arg1_hi, arg2_hi)
  res_lo = and_u32(arg1_lo, arg2_lo)
  RES = ( res_hi * 2^32 ) + res_lo
  return
}

fn and_u32(ARG_1 u32, ARG_2 u32) -> (RES u32) {
  var arg1_lo, arg1_hi, arg2_lo, arg2_hi, res_hi, res_lo u16
  arg1_hi, arg1_lo = ARG_1
  arg2_hi, arg2_lo = ARG_2
  res_hi = and_u16(arg1_hi, arg2_hi)
  res_lo = and_u16(arg1_lo, arg2_lo)
  RES = ( res_hi * 2^16 ) + res_lo
  return
}

fn and_u16(ARG_1 u16, ARG_2 u16) -> (RES u16) {
  var arg1_lo, arg1_hi, arg2_lo, arg2_hi, res_hi, res_lo u8
  arg1_hi, arg1_lo = ARG_1
  arg2_hi, arg2_lo = ARG_2
  res_hi = and_u8(arg1_hi, arg2_hi)
  res_lo = and_u8(arg1_lo, arg2_lo)
  RES = ( res_hi * 2^8 ) + res_lo
  return
}

fn and_u8(ARG_1 u8, ARG_2 u8) -> (RES u8) {
  var arg1_lo, arg1_hi, arg2_lo, arg2_hi, res_hi, res_lo u4
  var limb1 u8
  arg1_hi, arg1_lo = ARG_1
  arg2_hi, arg2_lo = ARG_2
  res_hi = and_u4(arg1_hi, arg2_hi)
  res_lo = and_u4(arg1_lo, arg2_lo)
  RES = ( res_hi * 2^4 ) + res_lo
  return
}

fn and_u4(ARG_1 u4, ARG_2 u4) -> (RES u4) {
  var arg1_lo, arg1_hi, arg2_lo, arg2_hi, res_hi, res_lo u2
  var limb1 u4
  arg1_hi, arg1_lo = ARG_1
  arg2_hi, arg2_lo = ARG_2
  res_hi = and_u2(arg1_hi, arg2_hi)
  res_lo = and_u2(arg1_lo, arg2_lo)
  RES =  ( res_hi * 2^2 ) + res_lo
  return
}

fn and_u2(ARG_1 u2, ARG_2 u2) -> (RES u2) {
  var arg1_lo, arg1_hi, arg2_lo, arg2_hi, res_hi, res_lo, c0 u1
  arg1_hi, arg1_lo = ARG_1
  arg2_hi, arg2_lo = ARG_2
  res_hi = and_u1(arg1_hi, arg2_hi)
  res_lo = and_u1(arg1_lo, arg2_lo)
  RES =  ( res_hi * 2 ) + res_lo
  return
}

fn and_u1(ARG_1 u1, ARG_2 u1) -> (RES u1) {
  RES = ARG_1 * ARG_2
  return
}