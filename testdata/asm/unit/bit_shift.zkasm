;; Shift a u256 word a given number of bits to the left.  To shift by
;; n bits, this operation makes n calls.  Since this is used in
;; conjunction with the byte_shl, it only supports n <= 7.
fn bit_shl256(word u256, n u3) -> (res u256) {
  var head u1
  var tail u255
  var b u1
  var m u3
  ;; check for base case
  if n == 0 goto base
  ;; split of lead bit
  head, tail = word
  ;; decrement counter
  b,m = n - 1
  res = bit_shl256(2*tail, m)
  return
base:
  res = word
  return
}

;; Shift a u256 word a given number of bits to the right.  To shift by
;; n bits, this operation makes n calls.  Since this is used in
;; conjunction with the byte_shr, it only supports n <= 7.
fn bit_shr256(word u256, n u3) -> (res u256) {
  var head u255
  var tail u1
  var b u1
  var m u3
  ;; check for base case
  if n == 0 goto base
  head, tail = word
  ;; decrement counter
  b,m = n - 1
  res = bit_shr256(head, m)
  return
base:
  res = word
  return
}

fn bit_sar256(word u256, n u3) -> (res u256) {
  var head u254
  var tail u1
  var b, sign u1
  var m u3
  ;; check for base case
  if n == 0 goto base
  ;; split of sign + head
  sign, head, tail = word
  ;; decrement counter
  b,m = n - 1
  res = bit_sar256((sign * 0b11*2^254) + head, m)
  return
base:
  res = word
  return
}
